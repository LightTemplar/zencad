# Внутренняя кухня

## Геометрическое ядро.

Библиотека zencad базируется на геометрическом ядре OpenCascade. Для работы с OpenCascade используется тонкая прослойка [servoce](https://github.com/mirmik/servoce), определяющая небольшое количество базовых объектов, операций над ними и использующая pybind11 для создания API на стороне python. Практически все функции питоновского API библиотеки servoce отпускают GIL интерпретатора, что позволяет осуществлять работу с состоянием python в момент просчета геометрии.

## Кэширование.

Особенностью скриптового cad является необходимость перезапуска скрипта генерации геометрии при каждом обновлении модели. С ростом размера модели это приводит к значительному росту времени, требующегося на отрисовку геометрии. С целью решения этой проблемы вычислительно ёмкие операции ZenCad закешированы и ленифицированы силами библиотеки [evalcache](https://github.com/mirmik/evalcache). 

Вместо непосредственного расчета, evalcache строит дерево построения модели на основе хэшключей генерируемых объектов. Библиотека сохраняет в кэше на жестком диске все произведенные вычисления и в случае, если объект уже был расчитан ранее, достаёт его из кэша. evalcache отслеживает изменения параметров в дереве модели и на лету обновляет переставшие быть актуальными объекты вычисления.

Для отображения информации о том, как evalcache работает с данными можно активировать диагностический вывод:
```python
zencad.lazy.diag=True
```

Так как evalcache выполняет вычисления только в момент, когда объект в действительности запрошен, а не тогда, когда он объявлен, могут возникать проблемы с пониманием точки возникновения возможной ошибки.

В этом случае полезной может быть опция:
```python
zencad.lazy.fastdo=True
```
При активации этой опции evalcache будет производить вычисления непосредственно в момент объявления объекта.

## Графический интерфейс пользователя изнутри.
UNDER_CONSTRUCT

## Организация и взаимодействие потоков и процессов ZenCad.
Графический интерфейс ZenCad построен таким образом, чтобы по минимуму влиять на порядок вычислений в запускаемых скриптах. Для того, чтобы этого достичь, скрипты вызываются в отдельном процессе, пораждаемом путём вызова командной строки операционной системы (см. `zencad/gui/application.md`, `zencad.gui.__main__.py`). Общение между процессами осуществляется через каналы posix (или их аналоги). Зависимые процессы читают сообщения из stdin и отправляют сообщения через stdout. Консольный вывод зависимых процессов перехватывается системой пайпов и отправляется управляющему процессу со специальным маркером, чтобы тот в свою очередь вывел это сообщение на консоль. Поскольку система консольного вывода в результате получается довольно сложной и сама по себе требует отладки, отладочная информация отправляется в stderr, а не в stdout.

Существует две схемы запуска графического интерфейса пользователя. 

В первом случае графический интерфейс запускается непосредственно, путём применения команд (`zencad`, `python3 -m zencad`). Здесь графический интерфейс является корневым процессом. 

Во втором случае графический интерфейс пользователя создаётся функцией show(), из процесса интерпретатора python скрипта. В этом случае графический интерфейс пользователя является порожденным корневым процессом и, например, для работы с консольным выводом, перенаправляет вывод всех порожденных им скриптов в корневой процесс. Корневой процесс не уничтоается до окончания работы графического интерфейса, даже если в интерфейсе был открыт другой файл.

## Функция show.
В зависимости от контекста функция show может менять своё поведение (см. `zencad/showapi.py`).